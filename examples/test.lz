print(2 ** 0);
print(3 ** 1);
print(0 ** 2);
print(1 ** 7);
print(5 * 3);
print(3 * 1);
print(5 * 0);
print(0 * 2);
print(0 / 3);
print(5 / 0);
print(3 + 4);
print(2 + 2);
print(3 - 1);
print(2 - 5);
print(5 % 3);
print(3.4 + 2.7);

print(5 < 3);
print(2 < 4);
print(3 == 3);
print(2 != 3);
print(2 != 2);
print(1 >= 1);
print(2 <= 1);

print(-5);

let x: integer[] = [4, 5, 6];

print(x[2]);

for i in domain(5) {
    print(2 + 3);
}

while (2 < 4) {
    print(3 + 3);
    break;
}

print([[1, 2 + 2], [3, 4]]);

// this doesnt add to the output:
while (3 < 2) {
    print(2 + 4);
}

let added: integer = 5 + 4;

let test2: float = 4.56 + 2.43;
test2 = 2.34 + 2.343;
test2 = 4.683;

let y: boolean = false;

if y == true {
    print(2 + 4);
} else if y != true {
    print(3.23 / 2);
} else if 5 % 2 == 1 {
    print(5 ** 1);
} else {
    print(7);
}

let x1: integer[] = [4, 5 + 3, 6];

x1[2] = 5 + 3;

print(x1);

print(x1[2]);

fnc test(f: float): float = {
    // does not optimize if I put f + in here. That seems super complex and might be an issue with how core was made.
    return 4.2 + 5.687;
}

print(test(2.3 + 1.4));

obj t = Triangle(3, 4, 5 + 3);
print(t.perimeter());


let m: matrix = [[1, 2], [3, 4]];
print(m[0+1][0+1]);